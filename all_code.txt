File: cmd/server/main.go
--------------------------------------------------------------------------------
package main

import (
	"banking-system/internal/config"
	"banking-system/internal/db"
	"banking-system/internal/handlers"
	"banking-system/internal/repositories"
	"banking-system/internal/services"

	"github.com/gin-gonic/gin"
)

func main() {

	cfg := config.Load()

	// âœ… Capture DB connection
	dbConn := db.Connect(cfg.DBDsn)

	// Ensure schema is up to date without dropping existing data.
	db.AutoMigrate(dbConn)

	// Repositories
	accountRepo := repositories.NewAccountRepository(dbConn)
	transactionRepo := repositories.NewTransactionRepository(dbConn)
	loanRepo := repositories.NewLoanRepository(dbConn)
	loanPaymentRepo := repositories.NewLoanPaymentRepository(dbConn)
	bankRepo := repositories.NewBankRepository(dbConn)
	branchRepo := repositories.NewBranchRepository(dbConn)
	customerRepo := repositories.NewCustomerRepository(dbConn)

	// Services
	accountService := services.NewAccountService(accountRepo, transactionRepo, customerRepo, branchRepo, bankRepo, dbConn)
	loanService := services.NewLoanService(loanRepo, loanPaymentRepo, customerRepo, bankRepo, branchRepo, dbConn)
	bankService := services.NewBankService(bankRepo)
	branchService := services.NewBranchService(branchRepo)
	customerService := services.NewCustomerService(customerRepo)

	// Handlers
	accountHandler := handlers.NewAccountHandler(accountService)
	loanHandler := handlers.NewLoanHandler(loanService)
	bankHandler := handlers.NewBankHandler(bankService)
	branchHandler := handlers.NewBranchHandler(branchService)
	customerHandler := handlers.NewCustomerHandler(customerService)

	r := gin.Default()

	r.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{"status": "ok"})
	})
	// Bank routes
	r.POST("/banks", bankHandler.CreateBank)
	r.GET("/banks", bankHandler.GetBanks)

	// Branch routes
	r.POST("/branches", branchHandler.CreateBranch)
	r.GET("/branches", branchHandler.GetBranches)

	// Customer routes
	r.POST("/customers", customerHandler.CreateCustomer)
	r.GET("/customers/:id", customerHandler.GetCustomer)

	// Account routes
	r.POST("/accounts", accountHandler.OpenAccount)
	r.POST("/accounts/:id/deposit", accountHandler.Deposit)
	r.POST("/accounts/:id/withdraw", accountHandler.Withdraw)
	r.GET("/accounts/:id", accountHandler.GetAccount)
	r.GET("/accounts/:id/transactions", accountHandler.GetTransactions)
	r.POST("/accounts/transfer", accountHandler.Transfer)

	// Loan routes
	r.POST("/loans", loanHandler.CreateLoan)
	r.POST("/loans/:id/repay", loanHandler.RepayLoan)
	r.GET("/loans/:id", loanHandler.GetLoanDetails)

	r.Run(":8080")
}



File: internal/config/config.go
--------------------------------------------------------------------------------
package config

import (
	"log"
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	DBDsn string
}

func Load() Config {
	err := godotenv.Load()
	if err != nil {
		log.Println("No .env file found, using system env")
	}

	dsn := "host=" + os.Getenv("DB_HOST") + " " +
		"user=" + os.Getenv("DB_USER") + " " +
		"password=" + os.Getenv("DB_PASSWORD") + " " +
		"dbname=" + os.Getenv("DB_NAME") + " " +
		"port=" + os.Getenv("DB_PORT") + " " +
		"sslmode=" + os.Getenv("DB_SSLMODE")

	return Config{
		DBDsn: dsn,
	}
}



File: internal/db/migrate.go
--------------------------------------------------------------------------------
package db

import (
	"banking-system/internal/models"
	"log"

	"gorm.io/gorm"
)

// AutoMigrate runs GORM schema migrations for all domain models.
// Tables are created in dependency order so parents exist before children.
func AutoMigrate(database *gorm.DB) {
	if database == nil {
		log.Println("skipping auto-migration: database connection is nil")
		return
	}

	// Migrate in dependency order: parents before children
	batches := []interface{}{
		&models.Bank{},
		&models.Customer{},
		&models.Branch{},
		&models.Account{},
		&models.Transaction{},
		&models.Loan{},
		&models.LoanPayment{},
	}

	for _, model := range batches {
		if err := database.AutoMigrate(model); err != nil {
			log.Fatalf("auto-migration failed: %v", err)
		}
	}

	log.Println("database schema is up to date")
}



File: internal/db/postgres.go
--------------------------------------------------------------------------------
package db

import (
	"log"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

func Connect(dsn string) *gorm.DB {
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		DisableForeignKeyConstraintWhenMigrating: true,
	})
	if err != nil {
		log.Fatalf("failed to connect to database: %v", err)
	}

	log.Println("PostgreSQL connected successfully")
	log.Println("DB DSN:", dsn)

	return db
}



File: internal/handlers/account_handler.go
--------------------------------------------------------------------------------
package handlers

import (
	"banking-system/internal/services"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

type AccountHandler struct {
	service services.AccountService
}

func NewAccountHandler(service services.AccountService) *AccountHandler {
	return &AccountHandler{service: service}
}

// Deposit Handler
func (h *AccountHandler) Deposit(c *gin.Context) {
	accountIDParam := c.Param("id")
	accountID, err := strconv.Atoi(accountIDParam)
	if err != nil || accountID <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_ACCOUNT_ID", "account id must be a positive integer")
		return
	}

	var request struct {
		Amount float64 `json:"amount"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.Amount <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_AMOUNT", "amount must be greater than zero")
		return
	}

	account, err := h.service.Deposit(uint(accountID), request.Amount)
	if err != nil {
		respondError(c, http.StatusBadRequest, "DEPOSIT_FAILED", err.Error())
		return
	}

	respondSuccess(c, http.StatusOK, gin.H{
		"message":     "deposit successful",
		"transaction": "DEPOSIT",
		"amount":      request.Amount,
		"account":     account,
	})
}

// Withdraw Handler
func (h *AccountHandler) Withdraw(c *gin.Context) {
	accountIDParam := c.Param("id")
	accountID, err := strconv.Atoi(accountIDParam)
	if err != nil || accountID <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_ACCOUNT_ID", "account id must be a positive integer")
		return
	}

	var request struct {
		Amount float64 `json:"amount"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.Amount <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_AMOUNT", "amount must be greater than zero")
		return
	}

	account, err := h.service.Withdraw(uint(accountID), request.Amount)
	if err != nil {
		respondError(c, http.StatusBadRequest, "WITHDRAW_FAILED", err.Error())
		return
	}

	respondSuccess(c, http.StatusOK, gin.H{
		"message":     "withdraw successful",
		"transaction": "WITHDRAW",
		"amount":      request.Amount,
		"account":     account,
	})
}

// GET ACCOUNT HANDLER
func (h *AccountHandler) GetAccount(c *gin.Context) {
	accountIDParam := c.Param("id")
	accountID, err := strconv.Atoi(accountIDParam)
	if err != nil || accountID <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_ACCOUNT_ID", "account id must be a positive integer")
		return
	}

	account, err := h.service.GetAccount(uint(accountID))
	if err != nil {
		respondError(c, http.StatusNotFound, "ACCOUNT_NOT_FOUND", "account not found")
		return
	}

	respondSuccess(c, http.StatusOK, account)
}

func (h *AccountHandler) OpenAccount(c *gin.Context) {
	var request struct {
		CustomerID uint `json:"customer_id"`
		BankID     uint `json:"bank_id"`
		BranchID   uint `json:"branch_id"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.CustomerID == 0 || request.BankID == 0 || request.BranchID == 0 {
		respondError(c, http.StatusBadRequest, "INVALID_FIELDS", "customer_id, bank_id and branch_id are required")
		return
	}

	account, err := h.service.OpenAccount(request.CustomerID, request.BankID, request.BranchID)
	if err != nil {
		respondError(c, http.StatusBadRequest, "CREATE_ACCOUNT_FAILED", err.Error())
		return
	}

	respondSuccess(c, http.StatusCreated, gin.H{"account": account})
}

func (h *AccountHandler) Transfer(c *gin.Context) {
	var request struct {
		FromAccountID uint    `json:"from_account_id"`
		ToAccountID   uint    `json:"to_account_id"`
		Amount        float64 `json:"amount"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.FromAccountID == 0 || request.ToAccountID == 0 || request.Amount <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_FIELDS", "from_account_id, to_account_id and positive amount are required")
		return
	}

	if request.FromAccountID == request.ToAccountID {
		respondError(c, http.StatusBadRequest, "INVALID_ACCOUNTS", "source and destination accounts must differ")
		return
	}

	if err := h.service.Transfer(
		request.FromAccountID,
		request.ToAccountID,
		request.Amount,
	); err != nil {
		respondError(c, http.StatusBadRequest, "TRANSFER_FAILED", err.Error())
		return
	}

	fromAccount, _ := h.service.GetAccount(request.FromAccountID)
	toAccount, _ := h.service.GetAccount(request.ToAccountID)

	respondSuccess(c, http.StatusOK, gin.H{
		"message":      "transfer successful",
		"from_account": fromAccount,
		"to_account":   toAccount,
		"amount":       request.Amount,
	})
}

func (h *AccountHandler) GetTransactions(c *gin.Context) {
	accountIDParam := c.Param("id")
	accountID, err := strconv.Atoi(accountIDParam)
	if err != nil || accountID <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_ACCOUNT_ID", "account id must be a positive integer")
		return
	}

	transactions, err := h.service.GetTransactions(uint(accountID))
	if err != nil {
		respondError(c, http.StatusNotFound, "TRANSACTIONS_NOT_FOUND", "transactions not found")
		return
	}

	respondSuccess(c, http.StatusOK, transactions)
}



File: internal/handlers/bank_handler.go
--------------------------------------------------------------------------------
package handlers

import (
	"banking-system/internal/services"
	"net/http"

	"github.com/gin-gonic/gin"
)

type BankHandler struct {
	service services.BankService
}

func NewBankHandler(service services.BankService) *BankHandler {
	return &BankHandler{service: service}
}

func (h *BankHandler) CreateBank(c *gin.Context) {
	var request struct {
		Name string `json:"name"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.Name == "" {
		respondError(c, http.StatusBadRequest, "INVALID_NAME", "name is required")
		return
	}

	bank, err := h.service.CreateBank(request.Name)
	if err != nil {
		respondError(c, http.StatusBadRequest, "CREATE_BANK_FAILED", err.Error())
		return
	}

	respondSuccess(c, http.StatusCreated, gin.H{"bank": bank})
}

func (h *BankHandler) GetBanks(c *gin.Context) {
	banks, err := h.service.GetBanks()
	if err != nil {
		respondError(c, http.StatusInternalServerError, "FETCH_BANKS_FAILED", "failed to fetch banks")
		return
	}

	respondSuccess(c, http.StatusOK, banks)
}



File: internal/handlers/branch_handler.go
--------------------------------------------------------------------------------
package handlers

import (
	"banking-system/internal/services"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

type BranchHandler struct {
	service services.BranchService
}

func NewBranchHandler(service services.BranchService) *BranchHandler {
	return &BranchHandler{service: service}
}

func (h *BranchHandler) CreateBranch(c *gin.Context) {
	var request struct {
		BankID  uint   `json:"bank_id"`
		Name    string `json:"name"`
		Address string `json:"address"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.BankID == 0 || request.Name == "" || request.Address == "" {
		respondError(c, http.StatusBadRequest, "INVALID_FIELDS", "bank_id, name and address are required")
		return
	}

	branch, err := h.service.CreateBranch(request.BankID, request.Name, request.Address)
	if err != nil {
		respondError(c, http.StatusBadRequest, "CREATE_BRANCH_FAILED", err.Error())
		return
	}

	respondSuccess(c, http.StatusCreated, gin.H{"branch": branch})
}

func (h *BranchHandler) GetBranches(c *gin.Context) {
	bankIDStr := c.Query("bank_id")
	if bankIDStr == "" {
		respondError(c, http.StatusBadRequest, "MISSING_BANK_ID", "bank_id query parameter is required")
		return
	}

	bankID, err := strconv.Atoi(bankIDStr)
	if err != nil || bankID <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_BANK_ID", "bank_id must be a positive integer")
		return
	}

	branches, err := h.service.GetBranches(uint(bankID))
	if err != nil {
		respondError(c, http.StatusInternalServerError, "FETCH_BRANCHES_FAILED", "failed to fetch branches")
		return
	}

	respondSuccess(c, http.StatusOK, branches)
}



File: internal/handlers/customer_handler.go
--------------------------------------------------------------------------------
package handlers

import (
	"banking-system/internal/services"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

type CustomerHandler struct {
	service services.CustomerService
}

func NewCustomerHandler(service services.CustomerService) *CustomerHandler {
	return &CustomerHandler{service: service}
}

func (h *CustomerHandler) CreateCustomer(c *gin.Context) {
	var request struct {
		Name  string `json:"name"`
		Email string `json:"email"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.Name == "" || request.Email == "" {
		respondError(c, http.StatusBadRequest, "INVALID_FIELDS", "name and email are required")
		return
	}

	customer, err := h.service.CreateCustomer(request.Name, request.Email)
	if err != nil {
		respondError(c, http.StatusBadRequest, "CREATE_CUSTOMER_FAILED", err.Error())
		return
	}

	respondSuccess(c, http.StatusCreated, gin.H{"customer": customer})
}

func (h *CustomerHandler) GetCustomer(c *gin.Context) {
	idStr := c.Param("id")
	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_CUSTOMER_ID", "customer id must be a positive integer")
		return
	}

	customer, err := h.service.GetCustomer(uint(id))
	if err != nil {
		respondError(c, http.StatusNotFound, "CUSTOMER_NOT_FOUND", "customer not found")
		return
	}

	respondSuccess(c, http.StatusOK, customer)
}



File: internal/handlers/loan_handler.go
--------------------------------------------------------------------------------
package handlers

import (
	"banking-system/internal/services"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

type LoanHandler struct {
	service services.LoanService
}

func NewLoanHandler(service services.LoanService) *LoanHandler {
	return &LoanHandler{service: service}
}

func (h *LoanHandler) CreateLoan(c *gin.Context) {
	var request struct {
		CustomerID uint    `json:"customer_id"`
		BankID     uint    `json:"bank_id"`
		BranchID   uint    `json:"branch_id"`
		Principal  float64 `json:"principal"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.CustomerID == 0 || request.BankID == 0 || request.BranchID == 0 || request.Principal <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_FIELDS", "customer_id, bank_id, branch_id and positive principal are required")
		return
	}

	loan, err := h.service.CreateLoan(
		request.CustomerID,
		request.BankID,
		request.BranchID,
		request.Principal,
	)

	if err != nil {
		respondError(c, http.StatusBadRequest, "CREATE_LOAN_FAILED", err.Error())
		return
	}

	respondSuccess(c, http.StatusCreated, gin.H{"loan": loan})
}

func (h *LoanHandler) RepayLoan(c *gin.Context) {
	loanIDParam := c.Param("id")
	loanID, err := strconv.Atoi(loanIDParam)
	if err != nil || loanID <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_LOAN_ID", "loan id must be a positive integer")
		return
	}

	var request struct {
		Amount float64 `json:"amount"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		respondError(c, http.StatusBadRequest, "INVALID_BODY", "invalid request body")
		return
	}

	if request.Amount <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_AMOUNT", "amount must be greater than zero")
		return
	}

	loan, err := h.service.RepayLoan(uint(loanID), request.Amount)
	if err != nil {
		respondError(c, http.StatusBadRequest, "REPAY_LOAN_FAILED", err.Error())
		return
	}

	respondSuccess(c, http.StatusOK, gin.H{
		"message": "loan repayment successful",
		"loan":    loan,
	})
}

func (h *LoanHandler) GetLoanDetails(c *gin.Context) {
	loanIDParam := c.Param("id")
	loanID, err := strconv.Atoi(loanIDParam)
	if err != nil || loanID <= 0 {
		respondError(c, http.StatusBadRequest, "INVALID_LOAN_ID", "loan id must be a positive integer")
		return
	}

	loan, interest, err := h.service.GetLoanDetails(uint(loanID))
	if err != nil {
		respondError(c, http.StatusNotFound, "LOAN_NOT_FOUND", "loan not found")
		return
	}

	respondSuccess(c, http.StatusOK, gin.H{
		"loan":          loan,
		"interest_year": interest,
	})
}



File: internal/handlers/response.go
--------------------------------------------------------------------------------
package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

type apiError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

type apiResponse struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data,omitempty"`
	Error   *apiError   `json:"error,omitempty"`
}

func respondSuccess(c *gin.Context, status int, data interface{}) {
	if status == 0 {
		status = http.StatusOK
	}
	c.JSON(status, apiResponse{
		Success: true,
		Data:    data,
	})
}

func respondError(c *gin.Context, status int, code, message string) {
	if status == 0 {
		status = http.StatusInternalServerError
	}
	c.JSON(status, apiResponse{
		Success: false,
		Error: &apiError{
			Code:    code,
			Message: message,
		},
	})
}



File: internal/models/account.go
--------------------------------------------------------------------------------
package models

import "time"

type Account struct {
	AccountID  uint      `gorm:"column:account_id;primaryKey"`
	CustomerID uint      `gorm:"column:customer_id;not null"`
	BankID     uint      `gorm:"column:bank_id;not null"`
	BranchID   uint      `gorm:"column:branch_id;not null"`
	Balance    float64   `gorm:"column:balance;not null"`
	CreatedAt  time.Time `gorm:"column:created_at"`
	Type       string    `gorm:"column:type;default:'SAVINGS'"`
	Customer   Customer  `gorm:"foreignKey:CustomerID"`
	Branch     Branch    `gorm:"foreignKey:BranchID"`

	Transactions []Transaction `gorm:"foreignKey:AccountID"`
}

func (Account) TableName() string { return "accounts" }



File: internal/models/bank.go
--------------------------------------------------------------------------------
package models

import "time"

type Bank struct {
	BankID    uint      `gorm:"column:bank_id;primaryKey"`
	Name      string    `gorm:"column:name;not null"`
	CreatedAt time.Time `gorm:"column:created_at"`

	Branches []Branch `gorm:"foreignKey:BankID"`
	Loans    []Loan   `gorm:"foreignKey:BankID"`
}

func (Bank) TableName() string { return "banks" }



File: internal/models/branch.go
--------------------------------------------------------------------------------
package models

import "time"

type Branch struct {
	BranchID  uint      `gorm:"column:branch_id;primaryKey"`
	BankID    uint      `gorm:"column:bank_id;not null"`
	Name      string    `gorm:"column:name;not null"`
	Address   string    `gorm:"column:address;not null"`
	CreatedAt time.Time `gorm:"column:created_at"`

	Bank     Bank      `gorm:"foreignKey:BankID;references:BankID"`
	Accounts []Account `gorm:"foreignKey:BranchID"`
	Loans    []Loan    `gorm:"foreignKey:BranchID"`
}

func (Branch) TableName() string { return "branches" }



File: internal/models/customer.go
--------------------------------------------------------------------------------
package models

import "time"

type Customer struct {
	CustomerID uint      `gorm:"column:customer_id;primaryKey"`
	Name       string    `gorm:"column:name;not null"`
	Email      string    `gorm:"column:email;unique;not null"`
	CreatedAt  time.Time `gorm:"column:created_at"`

	Accounts []Account `gorm:"foreignKey:CustomerID"`
	Loans    []Loan    `gorm:"foreignKey:CustomerID"`
}

func (Customer) TableName() string { return "customers" }



File: internal/models/loan.go
--------------------------------------------------------------------------------
package models

import "time"

type Loan struct {
	LoanID          uint      `gorm:"column:loan_id;primaryKey"`
	CustomerID      uint      `gorm:"column:customer_id;not null"`
	BankID          uint      `gorm:"column:bank_id;not null"`
	BranchID        uint      `gorm:"column:branch_id;not null"`
	Principal       float64   `gorm:"column:principal;not null"`
	InterestRate    float64   `gorm:"column:interest_rate;not null"`
	RemainingAmount float64   `gorm:"column:remaining_amount;not null"`
	CreatedAt       time.Time `gorm:"column:created_at"`

	Customer Customer      `gorm:"foreignKey:CustomerID"`
	Bank     Bank          `gorm:"foreignKey:BankID"`
	Branch   Branch        `gorm:"foreignKey:BranchID"`
	Payments []LoanPayment `gorm:"foreignKey:LoanID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
}

func (Loan) TableName() string { return "loans" }



File: internal/models/loan_payment.go
--------------------------------------------------------------------------------
package models

import "time"

type LoanPayment struct {
	PaymentID  uint      `gorm:"column:payment_id;primaryKey"`
	LoanID     uint      `gorm:"column:loan_id;not null"`
	AmountPaid float64   `gorm:"column:amount_paid;not null"`
	CreatedAt  time.Time `gorm:"column:created_at"`
}

func (LoanPayment) TableName() string { return "loan_payments" }



File: internal/models/transaction.go
--------------------------------------------------------------------------------
package models

import "time"

type Transaction struct {
	TransactionID uint      `gorm:"column:transaction_id;primaryKey"`
	AccountID     uint      `gorm:"column:account_id;not null"`
	Type          string    `gorm:"column:type;not null"`
	Amount        float64   `gorm:"column:amount;not null"`
	CreatedAt     time.Time `gorm:"column:created_at"`

	Account Account `gorm:"foreignKey:AccountID"`
}

func (Transaction) TableName() string { return "transactions" }



File: internal/repositories/account_repository.go
--------------------------------------------------------------------------------
package repositories

import (
	"banking-system/internal/models"

	"gorm.io/gorm"
)

type AccountRepository interface {
	Create(account *models.Account) error
	GetByID(id uint) (*models.Account, error)
	UpdateBalance(accountID uint, newBalance float64) error
}

type accountRepository struct {
	db *gorm.DB
}

func NewAccountRepository(db *gorm.DB) AccountRepository {
	return &accountRepository{db: db}
}

func (r *accountRepository) Create(account *models.Account) error {
	return r.db.Create(account).Error
}

func (r *accountRepository) GetByID(id uint) (*models.Account, error) {
	var account models.Account
	err := r.db.First(&account, "account_id = ?", id).Error
	if err != nil {
		return nil, err
	}
	return &account, nil
}

func (r *accountRepository) UpdateBalance(accountID uint, newBalance float64) error {
	return r.db.Model(&models.Account{}).
		Where("account_id = ?", accountID).
		Update("balance", newBalance).Error
}



File: internal/repositories/bank_repository.go
--------------------------------------------------------------------------------
package repositories

import (
	"banking-system/internal/models"

	"gorm.io/gorm"
)

type BankRepository interface {
	Create(bank *models.Bank) error
	GetAll() ([]models.Bank, error)
	GetByID(id uint) (*models.Bank, error)
}

type bankRepository struct {
	db *gorm.DB
}

func NewBankRepository(db *gorm.DB) BankRepository {
	return &bankRepository{db: db}
}

func (r *bankRepository) Create(bank *models.Bank) error {
	return r.db.Create(bank).Error
}

func (r *bankRepository) GetAll() ([]models.Bank, error) {
	var banks []models.Bank
	err := r.db.Find(&banks).Error
	return banks, err
}

func (r *bankRepository) GetByID(id uint) (*models.Bank, error) {
	var bank models.Bank
	if err := r.db.First(&bank, "bank_id = ?", id).Error; err != nil {
		return nil, err
	}
	return &bank, nil
}



File: internal/repositories/branch_repository.go
--------------------------------------------------------------------------------
package repositories

import (
	"banking-system/internal/models"

	"gorm.io/gorm"
)

type BranchRepository interface {
	Create(branch *models.Branch) error
	GetByBank(bankID uint) ([]models.Branch, error)
	GetByID(id uint) (*models.Branch, error)
}

type branchRepository struct {
	db *gorm.DB
}

func NewBranchRepository(db *gorm.DB) BranchRepository {
	return &branchRepository{db: db}
}

func (r *branchRepository) Create(branch *models.Branch) error {
	return r.db.Create(branch).Error
}

func (r *branchRepository) GetByBank(bankID uint) ([]models.Branch, error) {
	var branches []models.Branch
	err := r.db.Where("bank_id = ?", bankID).Find(&branches).Error
	return branches, err
}

func (r *branchRepository) GetByID(id uint) (*models.Branch, error) {
	var branch models.Branch
	if err := r.db.First(&branch, "branch_id = ?", id).Error; err != nil {
		return nil, err
	}
	return &branch, nil
}



File: internal/repositories/customer_repository.go
--------------------------------------------------------------------------------
package repositories

import (
	"banking-system/internal/models"

	"gorm.io/gorm"
)

type CustomerRepository interface {
	Create(customer *models.Customer) error
	GetByID(id uint) (*models.Customer, error)
	GetAll() ([]models.Customer, error)
}

type customerRepository struct {
	db *gorm.DB
}

func NewCustomerRepository(db *gorm.DB) CustomerRepository {
	return &customerRepository{db: db}
}

func (r *customerRepository) Create(customer *models.Customer) error {
	return r.db.Create(customer).Error
}

func (r *customerRepository) GetByID(id uint) (*models.Customer, error) {
	var customer models.Customer
	err := r.db.First(&customer, "customer_id = ?", id).Error
	if err != nil {
		return nil, err
	}
	return &customer, nil
}

func (r *customerRepository) GetAll() ([]models.Customer, error) {
	var customers []models.Customer
	err := r.db.Find(&customers).Error
	return customers, err
}



File: internal/repositories/loan_payment_repository.go
--------------------------------------------------------------------------------
package repositories

import (
	"banking-system/internal/models"

	"gorm.io/gorm"
)

type LoanPaymentRepository interface {
	Create(payment *models.LoanPayment) error
	GetByLoanID(loanID uint) ([]models.LoanPayment, error)
}

type loanPaymentRepository struct {
	db *gorm.DB
}

func NewLoanPaymentRepository(db *gorm.DB) LoanPaymentRepository {
	return &loanPaymentRepository{db: db}
}

func (r *loanPaymentRepository) Create(payment *models.LoanPayment) error {
	return r.db.Create(payment).Error
}

func (r *loanPaymentRepository) GetByLoanID(loanID uint) ([]models.LoanPayment, error) {
	var payments []models.LoanPayment
	err := r.db.
		Where("loan_id = ?", loanID).
		Order("created_at desc").
		Find(&payments).Error

	return payments, err
}



File: internal/repositories/loan_repository.go
--------------------------------------------------------------------------------
package repositories

import (
	"banking-system/internal/models"

	"gorm.io/gorm"
)

type LoanRepository interface {
	Create(loan *models.Loan) error
	GetByID(id uint) (*models.Loan, error)
	UpdateRemainingAmount(loanID uint, amount float64) error
}

type loanRepository struct {
	db *gorm.DB
}

func NewLoanRepository(db *gorm.DB) LoanRepository {
	return &loanRepository{db: db}
}

func (r *loanRepository) Create(loan *models.Loan) error {
	return r.db.Create(loan).Error
}

func (r *loanRepository) GetByID(id uint) (*models.Loan, error) {
	var loan models.Loan
	err := r.db.First(&loan, "loan_id = ?", id).Error
	if err != nil {
		return nil, err
	}
	return &loan, nil
}

func (r *loanRepository) UpdateRemainingAmount(loanID uint, amount float64) error {
	return r.db.Model(&models.Loan{}).
		Where("loan_id = ?", loanID).
		Update("remaining_amount", amount).Error
}



File: internal/repositories/transaction_repository.go
--------------------------------------------------------------------------------
package repositories

import (
	"banking-system/internal/models"

	"gorm.io/gorm"
)

type TransactionRepository interface {
	Create(tx *models.Transaction) error
	GetByAccountID(accountID uint) ([]models.Transaction, error)
}

type transactionRepository struct {
	db *gorm.DB
}

func NewTransactionRepository(db *gorm.DB) TransactionRepository {
	return &transactionRepository{db: db}
}

func (r *transactionRepository) Create(tx *models.Transaction) error {
	return r.db.Create(tx).Error
}

func (r *transactionRepository) GetByAccountID(accountID uint) ([]models.Transaction, error) {
	var transactions []models.Transaction
	err := r.db.
		Where("account_id = ?", accountID).
		Order("created_at desc").
		Find(&transactions).Error

	return transactions, err
}



File: internal/services/account_service.go
--------------------------------------------------------------------------------
package services

import (
	"banking-system/internal/models"
	"banking-system/internal/repositories"
	"errors"

	"gorm.io/gorm"
)

type AccountService interface {
	OpenAccount(customerID, bankID, branchID uint) (*models.Account, error)
	Deposit(accountID uint, amount float64) (*models.Account, error)
	Withdraw(accountID uint, amount float64) (*models.Account, error)
	GetAccount(accountID uint) (*models.Account, error)
	Transfer(fromID, toID uint, amount float64) error
	GetTransactions(accountID uint) ([]models.Transaction, error)
}

type accountService struct {
	accountRepo     repositories.AccountRepository
	transactionRepo repositories.TransactionRepository
	db              *gorm.DB
	customerRepo    repositories.CustomerRepository
	branchRepo      repositories.BranchRepository
	bankRepo        repositories.BankRepository
}

func NewAccountService(
	accountRepo repositories.AccountRepository,
	transactionRepo repositories.TransactionRepository,
	customerRepo repositories.CustomerRepository,
	branchRepo repositories.BranchRepository,
	bankRepo repositories.BankRepository,
	db *gorm.DB,
) AccountService {
	return &accountService{
		accountRepo:     accountRepo,
		transactionRepo: transactionRepo,
		customerRepo:    customerRepo,
		branchRepo:      branchRepo,
		bankRepo:        bankRepo,
		db:              db,
	}
}

func (s *accountService) Deposit(accountID uint, amount float64) (*models.Account, error) {
	if amount <= 0 {
		return nil, errors.New("deposit amount must be positive")
	}

	var updatedAccount *models.Account

	err := s.db.Transaction(func(tx *gorm.DB) error {
		account, err := s.accountRepo.GetByID(accountID)
		if err != nil {
			return err
		}

		newBalance := account.Balance + amount
		if err := s.accountRepo.UpdateBalance(accountID, newBalance); err != nil {
			return err
		}
		account.Balance = newBalance

		transaction := models.Transaction{
			AccountID: accountID,
			Type:      "DEPOSIT",
			Amount:    amount,
		}

		if err := s.transactionRepo.Create(&transaction); err != nil {
			return err
		}

		updatedAccount = account
		return nil
	})

	if err != nil {
		return nil, err
	}

	return updatedAccount, nil
}

func (s *accountService) Withdraw(accountID uint, amount float64) (*models.Account, error) {
	if amount <= 0 {
		return nil, errors.New("withdraw amount must be positive")
	}

	var updatedAccount *models.Account

	err := s.db.Transaction(func(tx *gorm.DB) error {
		account, err := s.accountRepo.GetByID(accountID)
		if err != nil {
			return err
		}

		if account.Balance < amount {
			return errors.New("insufficient balance")
		}

		newBalance := account.Balance - amount

		if err := s.accountRepo.UpdateBalance(accountID, newBalance); err != nil {
			return err
		}

		transaction := models.Transaction{
			AccountID: accountID,
			Type:      "WITHDRAW",
			Amount:    amount,
		}

		if err := s.transactionRepo.Create(&transaction); err != nil {
			return err
		}

		account.Balance = newBalance
		updatedAccount = account

		return nil
	})

	if err != nil {
		return nil, err
	}

	return updatedAccount, nil
}

func (s *accountService) GetAccount(accountID uint) (*models.Account, error) {
	return s.accountRepo.GetByID(accountID)
}

func (s *accountService) Transfer(fromID, toID uint, amount float64) error {
	if amount <= 0 {
		return errors.New("transfer amount must be positive")
	}

	return s.db.Transaction(func(tx *gorm.DB) error {

		fromAccount, err := s.accountRepo.GetByID(fromID)
		if err != nil {
			return err
		}

		toAccount, err := s.accountRepo.GetByID(toID)
		if err != nil {
			return err
		}

		if fromAccount.Balance < amount {
			return errors.New("insufficient balance")
		}

		// Deduct from sender
		if err := s.accountRepo.UpdateBalance(fromID, fromAccount.Balance-amount); err != nil {
			return err
		}

		// Add to receiver
		if err := s.accountRepo.UpdateBalance(toID, toAccount.Balance+amount); err != nil {
			return err
		}

		// Create transaction records
		if err := s.transactionRepo.Create(&models.Transaction{
			AccountID: fromID,
			Type:      "TRANSFER_OUT",
			Amount:    amount,
		}); err != nil {
			return err
		}

		if err := s.transactionRepo.Create(&models.Transaction{
			AccountID: toID,
			Type:      "TRANSFER_IN",
			Amount:    amount,
		}); err != nil {
			return err
		}

		return nil
	})
}

func (s *accountService) GetTransactions(accountID uint) ([]models.Transaction, error) {
	return s.transactionRepo.GetByAccountID(accountID)
}

func (s *accountService) OpenAccount(customerID, bankID, branchID uint) (*models.Account, error) {

	// Validate customer exists
	_, err := s.customerRepo.GetByID(customerID)
	if err != nil {
		return nil, errors.New("customer does not exist")
	}

	// Validate bank exists
	if _, err := s.bankRepo.GetByID(bankID); err != nil {
		return nil, errors.New("bank does not exist")
	}

	// Validate branch exists and belongs to the bank
	branch, err := s.branchRepo.GetByID(branchID)
	if err != nil {
		return nil, errors.New("branch does not exist")
	}
	if branch.BankID != bankID {
		return nil, errors.New("branch does not belong to bank")
	}

	account := models.Account{
		CustomerID: customerID,
		BankID:     bankID,
		BranchID:   branchID,
		Balance:    0,
	}

	if err := s.accountRepo.Create(&account); err != nil {
		return nil, err
	}

	return &account, nil
}



File: internal/services/bank_service.go
--------------------------------------------------------------------------------
package services

import (
	"banking-system/internal/models"
	"banking-system/internal/repositories"
)

type BankService interface {
	CreateBank(name string) (*models.Bank, error)
	GetBanks() ([]models.Bank, error)
}

type bankService struct {
	bankRepo repositories.BankRepository
}

func NewBankService(bankRepo repositories.BankRepository) BankService {
	return &bankService{bankRepo: bankRepo}
}

func (s *bankService) CreateBank(name string) (*models.Bank, error) {
	bank := models.Bank{
		Name: name,
	}
	if err := s.bankRepo.Create(&bank); err != nil {
		return nil, err
	}
	return &bank, nil
}

func (s *bankService) GetBanks() ([]models.Bank, error) {
	return s.bankRepo.GetAll()
}



File: internal/services/branch_service.go
--------------------------------------------------------------------------------
package services

import (
	"banking-system/internal/models"
	"banking-system/internal/repositories"
)

type BranchService interface {
	CreateBranch(bankID uint, name, address string) (*models.Branch, error)
	GetBranches(bankID uint) ([]models.Branch, error)
}

type branchService struct {
	branchRepo repositories.BranchRepository
}

func NewBranchService(branchRepo repositories.BranchRepository) BranchService {
	return &branchService{branchRepo: branchRepo}
}

func (s *branchService) CreateBranch(bankID uint, name, address string) (*models.Branch, error) {
	branch := models.Branch{
		BankID:  bankID,
		Name:    name,
		Address: address,
	}
	if err := s.branchRepo.Create(&branch); err != nil {
		return nil, err
	}
	return &branch, nil
}

func (s *branchService) GetBranches(bankID uint) ([]models.Branch, error) {
	return s.branchRepo.GetByBank(bankID)
}



File: internal/services/cutomer_service.go
--------------------------------------------------------------------------------
package services

import (
	"banking-system/internal/models"
	"banking-system/internal/repositories"
)

type CustomerService interface {
	CreateCustomer(name, email string) (*models.Customer, error)
	GetCustomer(id uint) (*models.Customer, error)
}

type customerService struct {
	customerRepo repositories.CustomerRepository
}

func NewCustomerService(customerRepo repositories.CustomerRepository) CustomerService {
	return &customerService{customerRepo: customerRepo}
}

func (s *customerService) CreateCustomer(name, email string) (*models.Customer, error) {
	customer := models.Customer{
		Name:  name,
		Email: email,
	}
	if err := s.customerRepo.Create(&customer); err != nil {
		return nil, err
	}
	return &customer, nil
}

func (s *customerService) GetCustomer(id uint) (*models.Customer, error) {
	return s.customerRepo.GetByID(id)
}



File: internal/services/loan_service.go
--------------------------------------------------------------------------------
package services

import (
	"banking-system/internal/models"
	"banking-system/internal/repositories"
	"errors"

	"gorm.io/gorm"
)

type LoanService interface {
	CreateLoan(customerID, bankID, branchID uint, principal float64) (*models.Loan, error)
	RepayLoan(loanID uint, amount float64) (*models.Loan, error)
	GetLoanDetails(loanID uint) (*models.Loan, float64, error)
}

type loanService struct {
	loanRepo     repositories.LoanRepository
	paymentRepo  repositories.LoanPaymentRepository
	db           *gorm.DB
	customerRepo repositories.CustomerRepository
	bankRepo     repositories.BankRepository
	branchRepo   repositories.BranchRepository
}

func NewLoanService(
	loanRepo repositories.LoanRepository,
	paymentRepo repositories.LoanPaymentRepository,
	customerRepo repositories.CustomerRepository,
	bankRepo repositories.BankRepository,
	branchRepo repositories.BranchRepository,
	db *gorm.DB,
) LoanService {
	return &loanService{
		loanRepo:     loanRepo,
		paymentRepo:  paymentRepo,
		db:           db,
		customerRepo: customerRepo,
		bankRepo:     bankRepo,
		branchRepo:   branchRepo,
	}
}

func (s *loanService) CreateLoan(customerID, bankID, branchID uint, principal float64) (*models.Loan, error) {
	if principal <= 0 {
		return nil, errors.New("principal must be positive")
	}

	if _, err := s.customerRepo.GetByID(customerID); err != nil {
		return nil, errors.New("customer does not exist")
	}

	if _, err := s.bankRepo.GetByID(bankID); err != nil {
		return nil, errors.New("bank does not exist")
	}

	branch, err := s.branchRepo.GetByID(branchID)
	if err != nil {
		return nil, errors.New("branch does not exist")
	}
	if branch.BankID != bankID {
		return nil, errors.New("branch does not belong to bank")
	}

	loan := models.Loan{
		CustomerID:      customerID,
		BankID:          bankID,
		BranchID:        branchID,
		Principal:       principal,
		InterestRate:    12.0, // fixed as per assignment
		RemainingAmount: principal,
	}

	if err := s.loanRepo.Create(&loan); err != nil {
		return nil, err
	}

	return &loan, nil
}

func (s *loanService) RepayLoan(loanID uint, amount float64) (*models.Loan, error) {
	if amount <= 0 {
		return nil, errors.New("repayment amount must be positive")
	}

	var updatedLoan *models.Loan

	err := s.db.Transaction(func(tx *gorm.DB) error {

		loan, err := s.loanRepo.GetByID(loanID)
		if err != nil {
			return err
		}

		if loan.RemainingAmount < amount {
			return errors.New("repayment exceeds remaining amount")
		}

		newRemaining := loan.RemainingAmount - amount

		if err := s.loanRepo.UpdateRemainingAmount(loanID, newRemaining); err != nil {
			return err
		}

		payment := models.LoanPayment{
			LoanID:     loanID,
			AmountPaid: amount,
		}

		if err := s.paymentRepo.Create(&payment); err != nil {
			return err
		}

		loan.RemainingAmount = newRemaining
		updatedLoan = loan

		return nil
	})

	if err != nil {
		return nil, err
	}

	return updatedLoan, nil
}

func (s *loanService) GetLoanDetails(loanID uint) (*models.Loan, float64, error) {
	loan, err := s.loanRepo.GetByID(loanID)
	if err != nil {
		return nil, 0, err
	}

	// yearly interest
	interestThisYear := loan.RemainingAmount * (loan.InterestRate / 100)

	return loan, interestThisYear, nil
}



